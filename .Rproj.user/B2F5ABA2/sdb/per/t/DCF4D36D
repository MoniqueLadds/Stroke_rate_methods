{
    "collab_server" : "",
    "contents" : "diffs<-function(x) x-df$strokes\nrange<-function(x) max(x)-min(x)\nmeans<-function(x) tapply(x,df$name,mean)\ntime_rate<-function(x) x/(df$time_dive)\n\n\nfind_peaks <- function (x, m = 3){\n  shape <- diff(sign(diff(x, na.pad = FALSE)))\n  pks <- sapply(which(shape < 0), FUN = function(i){\n    z <- i - m + 1\n    z <- ifelse(z > 0, z, 1)\n    w <- i + m + 1\n    w <- ifelse(w < length(x), w, length(x))\n    if(all(x[c(z : i, (i + 2) : w)] <= x[i + 1])) return(i + 1) else return(numeric(0))\n  })\n  pks <- unlist(pks)\n  pks\n}\n\n\npanel.cor <- function(x, y, digits=2, prefix=\"\", cex.cor, ...)\n{\n  usr <- par(\"usr\"); on.exit(par(usr))\n  par(usr = c(0, 1, 0, 1))\n  r <- abs(cor(x, y))\n  txt <- format(c(r, 0.123456789), digits=digits)[1]\n  txt <- paste(prefix, txt, sep=\"\")\n  if(missing(cex.cor)) cex.cor <- 0.8/strwidth(txt)\n  text(0.5, 0.5, txt, cex = cex.cor * r)\n}\n\npanel.pearson <- function(x, y, ...) {\n  horizontal <- (par(\"usr\")[1] + par(\"usr\")[2]) / 2; \n  vertical <- (par(\"usr\")[3] + par(\"usr\")[4]) / 2; \n  text(horizontal, vertical, format(abs(cor(x,y)), digits=2)) \n}\n\nslopeDiff<-function(model1,model2){\n  b1<-model1$coefficients[2]\n  b2<-model2$coefficients[2]\n  seb1<-summary(model1)$coefficients[2,2]\n  seb2<-summary(model2)$coefficients[2,2]\n  z<-(b1-b2)/sqrt(seb1^2+seb2^2)\n  p<-(2*pnorm(-abs(z)))\n  out<-c(z,p)\n  names(out)<-c(\"z\",\"p\")\n  return(out)\n}\n\n\nfline <- function(object) { \n  # ``fline'' <--> fitted line. \n  r <- range(object$model[,2]) \n  d <- data.frame(r) \n  names(d) <- attr(object$terms,\"term.labels\") \n  y <- predict(object,d) \n  lines(r,y) \n} \n\nassumptions<-function(model){\n  modresid<-resid(model)\n  modpredict<-predict(model)\n  modstres<-(modresid-mean(modresid)/sd(modresid))\n  modstpre<-(modpredict-mean(modpredict)/sd(modpredict))\n  par(mfrow=c(2,2))\n  qqnorm(modstres)\n  qqline(resid(model))\n  acf(resid(model))\n  plot(modstpre, modstres, main = \"Standardized Residuals Plot\", \n       xlab = \"Standardized Predicted Values\", ylab = \"Standardized Residuals\")\n  abline(0,0)\n  hist(modstres, freq = FALSE,\n       main=\"Histogram of Standardised Residuals\")\n  curve(dnorm(x, mean = mean(modstres), sd = sd(modstres)),\n        add=TRUE, col = \"red\")\n}\n\nlm.results <-\n  function(lm)\n  {\n    out <- c(lm$coefficients[1],\n             lm$coefficients[2],\n             summary(lm)$coefficients[2,2],\n             pf(summary(lm)$fstatistic[1], summary(lm)$fstatistic[2],\n                summary(lm)$fstatistic[3], lower.tail = FALSE),\n             summary(lm)$r.squared,\n             logLik(lm))\n    names(out) <- c(\"intercept\",\"slope\",\"slope.SE\",\"p.value\",\"r.squared\",\"logLik\")\n    return(out)}\n\nlme.results <-\n  function(lm)\n  {  \n    out <- c(summary(lm)$AIC,\n             summary(lm)$logLik,\n             r.squared.lme(lm)$Marginal,\n             r.squared.lme(lm)$Conditional)\n    names(out) <- c(\"AIC\",\"LogLik\",\"r.squared(fixed)\",\"r.squared(all)\")\n    return(out)}\n\n\nstatmod <- function(x) {\n  z <- table(as.vector(x))\n  names(z)[z == max(z)]\n}\n\nse<-function(x){\n  sd(x)/sqrt(length(x))\n}\n\nerror<-function(n){\n  qnorm(0.975)*sd/sqrt(n)}\n\n\nHampelFilter <- function (x, k,t0=3){\n  n <- length(x)\n  y <- x\n  ind <- c()\n  L <- 1.4826\n  for (i in (k + 1):(n - k)) {\n    x0 <- median(x[(i - k):(i + k)])\n    S0 <- L * median(abs(x[(i - k):(i + k)] - x0))\n    if (abs(x[i] - x0) > t0 * S0) {\n      y[i] <- x0\n      ind <- c(ind, i)\n    }\n  }\n  list(y = y, ind = ind)\n}\n\n\n#' R-squared and pseudo-rsquared for a list of (generalized) linear (mixed) models\n#'\n#' This function calls the generic \\code{\\link{r.squared}} function for each of the\n#' models in the list and rbinds the outputs into one data frame\n#'\n#' @param a list of fitted (generalized) linear (mixed) model objects\n#' @return a dataframe with one row per model, and \"Class\",\n#'         \"Family\", \"Marginal\", \"Conditional\" and \"AIC\" columns\nrsquared.glmm <- function(modlist) {\n  # Iterate over each model in the list\n  do.call(rbind, lapply(modlist, r.squared))\n}\n\n#' R-squared and pseudo-rsquared for (generalized) linear (mixed) models\n#'\n#' This generic function calculates the r squared and pseudo r-squared for\n#' a variety of(generalized) linear (mixed) model fits.\n#' Currently implemented for \\code{\\link{lm}}, \\code{\\link{lmerTest::merMod}},\n#' and \\code{\\link{nlme::lme}} objects.\n#' Implementing methods usually call \\code{\\link{.rsquared.glmm}}\n#'\n#' @param mdl a fitted (generalized) linear (mixed) model object\n#' @return Implementing methods usually return a dataframe with \"Class\",\n#'         \"Family\", \"Marginal\", \"Conditional\", and \"AIC\" columns\nr.squared <- function(mdl){\n  UseMethod(\"r.squared\")\n}\n\n#' Marginal r-squared for lm objects\n#'\n#' This method uses r.squared from \\code{\\link{summary}} as the marginal.\n#' Contrary to other \\code{\\link{r.squared}} methods, \n#' this one doesn't call \\code{\\link{.rsquared.glmm}}\n#'\n#' @param mdl an lm object (usually fit using \\code{\\link{lm}},\n#' @return a dataframe with with \"Class\" = \"lm\", \"Family\" = \"gaussian\",\n#'        \"Marginal\" = unadjusted r-squared, \"Conditional\" = NA, and \"AIC\" columns\nr.squared.lm <- function(mdl){\n  data.frame(Class=class(mdl), Family=\"gaussian\", Link=\"identity\",\n             Marginal=summary(mdl)$r.squared,\n             Conditional=NA, AIC=AIC(mdl))\n}\n\n#' Marginal and conditional r-squared for merMod objects\n#'\n#' This method extracts the variance for fixed and random effects, residuals,\n#' and the fixed effects for the null model (in the case of Poisson family),\n#' and calls \\code{\\link{.rsquared.glmm}}\n#'\n#' @param mdl an merMod model (usually fit using \\code{\\link{lme4::lmer}},\n#'        \\code{\\link{lme4::glmer}}, \\code{\\link{lmerTest::lmer}},\n#'        \\code{\\link{blme::blmer}}, \\code{\\link{blme::bglmer}}, etc)\nr.squared.merMod <- function(mdl){\n  # Get variance of fixed effects by multiplying coefficients by design matrix\n  VarF <- var(as.vector(lme4::fixef(mdl) %*% t(mdl@pp$X)))\n  # Get variance of random effects by extracting variance components\n  # Omit random effects at the observation level, variance is factored in later\n  VarRand <- sum(\n    sapply(\n      VarCorr(mdl)[!sapply(unique(unlist(strsplit(names(ranef(mdl)),\":|/\"))), function(l) length(unique(mdl@frame[,l])) == nrow(mdl@frame))],\n      function(Sigma) {\n        X <- model.matrix(mdl)\n        Z <- X[,rownames(Sigma)]\n        sum(diag(Z %*% Sigma %*% t(Z)))/nrow(X) } ) )\n  # Get the dispersion variance\n  VarDisp <- unlist(VarCorr(mdl)[sapply(unique(unlist(strsplit(names(ranef(mdl)),\":|/\"))), function(l) length(unique(mdl@frame[,l])) == nrow(mdl@frame))])\n  if(is.null(VarDisp)) VarDisp = 0 else VarDisp = VarDisp\n  if(inherits(mdl, \"lmerMod\")){\n    # Get residual variance\n    VarResid <- attr(lme4::VarCorr(mdl), \"sc\")^2\n    # Get ML model AIC\n    mdl.aic <- AIC(update(mdl, REML=F))\n    # Model family for lmer is gaussian\n    family <- \"gaussian\"\n    # Model link for lmer is identity\n    link <- \"identity\"\n  }\n  else if(inherits(mdl, \"glmerMod\")){\n    # Get the model summary\n    mdl.summ <- summary(mdl)\n    # Get the model's family, link and AIC\n    family <- mdl.summ$family\n    link <- mdl.summ$link\n    mdl.aic <- AIC(mdl)\n    # Pseudo-r-squared for poisson also requires the fixed effects of the null model\n    if(family==\"poisson\") {\n      # Get random effects names to generate null model\n      rand.formula <- reformulate(sapply(findbars(formula(mdl)),\n                                         function(x) paste0(\"(\", deparse(x), \")\")),\n                                  response=\".\")\n      # Generate null model (intercept and random effects only, no fixed effects)\n      null.mdl <- update(mdl, rand.formula)\n      # Get the fixed effects of the null model\n      null.fixef <- as.numeric(lme4::fixef(null.mdl))\n    }\n  }\n  # Call the internal function to do the pseudo r-squared calculations\n  .rsquared.glmm(VarF, VarRand, VarResid, VarDisp, family = family, link = link,\n                 mdl.aic = mdl.aic,\n                 mdl.class = class(mdl),\n                 null.fixef = null.fixef)\n}\n\n#' Marginal and conditional r-squared for lme objects\n#'\n#' This method extracts the variance for fixed and random effects,\n#' as well as residuals, and calls \\code{\\link{.rsquared.glmm}}\n#'\n#' @param mdl an lme model (usually fit using \\code{\\link{nlme::lme}})\nr.squared.lme <- function(mdl){\n  # Get design matrix of fixed effects from model\n  Fmat <- model.matrix(eval(mdl$call$fixed)[-2], mdl$data)\n  # Get variance of fixed effects by multiplying coefficients by design matrix\n  VarF <- var(as.vector(nlme::fixef(mdl) %*% t(Fmat)))\n  # Get variance of random effects by extracting variance components\n  VarRand <- sum(suppressWarnings(as.numeric(nlme::VarCorr(mdl)\n                                             [rownames(nlme::VarCorr(mdl)) != \"Residual\",\n                                              1])), na.rm=T)\n  # Get residual variance\n  VarResid <- as.numeric(nlme::VarCorr(mdl)[rownames(nlme::VarCorr(mdl))==\"Residual\", 1])\n  # Call the internal function to do the pseudo r-squared calculations\n  .rsquared.glmm(VarF, VarRand, VarResid, family = \"gaussian\", link = \"identity\",\n                 mdl.aic = AIC(update(mdl, method=\"ML\")),\n                 mdl.class = class(mdl))\n}\n\n#' Marginal and conditional r-squared for glmm given fixed and random variances\n#'\n#' This function is based on Nakagawa and Schielzeth (2013). It returns the marginal\n#' and conditional r-squared, as well as the AIC for each glmm.\n#' Users should call the higher-level generic \"r.squared\", or implement a method for the\n#' corresponding class to get varF, varRand and the family from the specific object\n#'\n#' @param varF Variance of fixed effects\n#' @param varRand Variance of random effects\n#' @param varResid Residual variance. Only necessary for \"gaussian\" family\n#' @param family family of the glmm (currently works with gaussian, binomial and poisson)\n#' @param link model link function. Working links are: gaussian: \"identity\" (default);\n#'        binomial: \"logit\" (default), \"probit\"; poisson: \"log\" (default), \"sqrt\"\n#' @param mdl.aic The model's AIC\n#' @param mdl.class The name of the model's class\n#' @param null.fixef Numeric vector containing the fixed effects of the null model.\n#'        Only necessary for \"poisson\" family\n#' @return A data frame with \"Class\", \"Family\", \"Marginal\", \"Conditional\", and \"AIC\" columns\n.rsquared.glmm <- function(varF, varRand, varResid = NULL, varDisp = NULL, family, link,\n                           mdl.aic, mdl.class, null.fixef = NULL){\n  if(family == \"gaussian\"){\n    # Only works with identity link\n    if(link != \"identity\")\n      family_link.stop(family, link)\n    # Calculate marginal R-squared (fixed effects/total variance)\n    Rm <- varF/(varF+varRand+varResid)\n    # Calculate conditional R-squared (fixed effects+random effects/total variance)\n    Rc <- (varF+varRand)/(varF+varRand+varResid)\n  }\n  else if(family == \"binomial\"){\n    # Get the distribution-specific variance\n    if(link == \"logit\")\n      varDist <- (pi^2)/3\n    else if(link == \"probit\")\n      varDist <- 1\n    else\n      family_link.stop(family, link)\n    # Calculate marginal R-squared\n    Rm <- varF/(varF+varRand+varDist+varDisp)\n    # Calculate conditional R-squared (fixed effects+random effects/total variance)\n    Rc <- (varF+varRand)/(varF+varRand+varDist+varDisp)\n  }\n  else if(family == \"poisson\"){\n    # Get the distribution-specific variance\n    if(link == \"log\")\n      varDist <- log(1+1/exp(null.fixef))\n    else if(link == \"sqrt\")\n      varDist <- 0.25\n    else\n      family_link.stop(family, link)\n    # Calculate marginal R-squared\n    Rm <- varF/(varF+varRand+varDist+varDisp)\n    # Calculate conditional R-squared (fixed effects+random effects/total variance)\n    Rc <- (varF+varRand)/(varF+varRand+varDist+varDisp)\n  }\n  else\n    family_link.stop(family, link)\n  # Bind R^2s into a matrix and return with AIC values\n  data.frame(Class=mdl.class, Family = family, Link = link,\n             Marginal=Rm, Conditional=Rc, AIC=mdl.aic)\n}\n\n#' stop execution if unable to calculate variance for a given family and link\nfamily_link.stop <- function(family, link){\n  stop(paste(\"Don't know how to calculate variance for\",\n             family, \"family and\", link, \"link.\"))\n}\n\nz.test=function(a, mu, var){\n  zeta = (mean(a) - mu)/\n    (sqrt(var/length(a)))\n  return(zeta)\n}\n\nmode<-function(x){\n  temp<-table(as.vector(x))\n  names(temp[temp==max(temp)])\n}",
    "created" : 1481742422031.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3307371574",
    "id" : "DCF4D36D",
    "lastKnownWriteTime" : 1481742713,
    "last_content_update" : 1481742713400,
    "path" : "~/Macquarie Uni/Stroke rate methods/R/harness/functions.R",
    "project_path" : "R/harness/functions.R",
    "properties" : {
    },
    "relative_order" : 5,
    "source_on_save" : true,
    "source_window" : "",
    "type" : "r_source"
}